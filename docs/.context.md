# Bale Inventory - Project Context

## Business Context

### Target Market
**Indian Textile Traders** - Small to medium-sized fabric trading businesses that:
- Buy fabric rolls from mills or suppliers
- Store inventory across multiple warehouses
- Sell to retailers, tailors, and manufacturers
- Need to track stock movement and orders
- Require barcode-based inventory management

### User Personas

**1. Demo User (Trial)**
- First-time visitor exploring the platform
- Gets instant access via magic link
- Views pre-loaded demo data (read-only)
- Evaluates features before requesting official access
- Can request invitation to become official customer

**2. Business Owner / Admin (Official Account)**
- Manages overall company operations
- Has multiple warehouses
- Needs visibility across all locations
- Makes strategic decisions based on inventory reports
- Manages staff and permissions
- Approved via invite-only system

**3. Warehouse Manager / Staff**
- Manages day-to-day warehouse operations
- Records goods receipts and dispatches
- Fulfills sales orders
- Scans barcodes for tracking
- Limited access to assigned warehouse only

**4. Customer (Public Catalog User)**
- Browses available fabrics
- Checks prices and availability
- Places orders online
- Tracks order status

### Business Workflows

#### 1. Procurement (Goods Receipt)
```
Supplier sends fabric â†’ Warehouse receives â†’ Create Goods Receipt
â†’ System creates Stock Units â†’ Stock available for sale
```

#### 2. Sales Order Fulfillment
```
Customer places order â†’ Admin/Staff reviews â†’ Approve order
â†’ Reserve stock units â†’ Create Goods Dispatch â†’ Mark order complete
```

#### 3. Job Work (Outsourcing)
```
Need processing (dyeing/printing) â†’ Create Job Work
â†’ Dispatch raw material to vendor â†’ Vendor processes
â†’ Receive finished goods â†’ Update inventory
```

#### 4. Warehouse Transfer
```
Stock needed in Warehouse B â†’ Create transfer dispatch from Warehouse A
â†’ Create receipt in Warehouse B â†’ Stock moved
```

## Technical Context

### Architecture Decisions

**Why Next.js?**
- Server-side rendering for better SEO (public catalog)
- App Router for clean file-based routing
- API routes for server-side operations
- Built-in optimization (images, fonts, code splitting)

**Why Supabase?**
- PostgreSQL with Row Level Security (RLS) for multi-tenancy
- Built-in authentication with JWT
- Real-time subscriptions (future enhancement)
- Storage for images
- Free tier sufficient for initial deployment

**Why Multi-Tenancy with RLS?**
- Complete data isolation between companies
- Security enforced at database level
- No risk of data leaks in application code
- Simplified permission logic

**Why Hostinger?**
- Cost-effective for Indian market
- Supports Node.js applications
- Easy deployment for small businesses
- Good uptime and support

### Database Design Philosophy

**Normalized Structure**
- Separate tables for each entity
- Foreign key relationships for data integrity
- Avoid duplication

**Audit Fields**
- Every table has: `created_at`, `updated_at`, `created_by`, `modified_by`
- Soft deletes with `deleted_at` for history
- Track who made changes for accountability

**Invite System Tables**
- `invites` table with two types: `platform` and `staff`
- Platform invites: No company_id (creates new company on acceptance)
- Staff invites: Has company_id and warehouse_id (joins existing company)
- Invite statuses: `pending`, `accepted`, `expired`, `revoked`
- 48-hour expiration by default
- 12-character alphanumeric codes (unique)

**Fabric-Specific Fields**
- `fabric_type`: Cotton, Polyester, Silk, Blend, etc.
- `gsm`: Grams per square meter (fabric weight)
- `color`: Name + hex code for accurate representation
- `measuring_unit`: Meters, yards, pieces, kg (different measurement systems)
- `quality_grade`: A, B, C, D (quality classification)

**Status-Driven Workflows**
- Stock Units: `in_stock` â†’ `reserved` â†’ `dispatched` â†’ `sold`
- Sales Orders: `draft` â†’ `approval_pending` â†’ `in_progress` â†’ `completed`/`cancelled`
- Dispatches: `pending` â†’ `in_transit` â†’ `delivered`/`cancelled`

### Security Model

**Row Level Security (RLS)**
Every query automatically filtered by:
1. **Company ID**: User can only see data from their company
2. **Warehouse ID**: Staff users limited to assigned warehouse
3. **Role**: Admin bypasses warehouse restrictions

**Example RLS Policy** (Stock Units):
```sql
-- Staff can only see stock in their assigned warehouse
CREATE POLICY "staff_access" ON stock_units
FOR SELECT
USING (
  company_id = auth.get_company_id()
  AND (
    auth.get_user_role() = 'admin'
    OR warehouse_id = auth.get_user_warehouse()
  )
);
```

**Authentication Flow** (Two-Tier System):
1. **Tier 1: Demo Access (Public)**
   - User enters email on homepage
   - Supabase sends magic link via `signInWithOtp()`
   - User clicks link â†’ Auth callback checks for invite
   - No invite found â†’ Assigned to shared demo company
   - User record created with `is_demo: true`, `role: customer`
   - RLS policies grant read-only access to demo company data

2. **Tier 2: Official Account (Invite-Only)**
   - Demo user explores features
   - Clicks "Request Official Access" â†’ Fills form
   - Admin reviews request in admin panel
   - Admin approves â†’ System generates invite code
   - User receives email with invite link
   - User clicks invite link â†’ Gets magic link
   - User clicks magic link â†’ Auth callback finds valid invite
   - New company + warehouse created
   - User record created with `is_demo: false`, `role: admin`
   - Invite marked as `accepted`

**Magic Link System**:
- Uses Supabase `signInWithOtp({ email, shouldCreateUser: true })`
- Auth hook validates invite existence (optional now)
- Callback determines: demo company vs new company
- PKCE flow requirement (same device/browser)
- Email sent via Resend (custom SMTP)
- Links expire after 1 hour
- Can request new link every 60 seconds

**Invite System Flow**:
1. **Platform Invite** (for new official companies):
   - Admin approves invite request â†’ Generates invite code
   - User receives invite email with code
   - **Magic Link (Primary)**: Click invite link â†’ Get magic link â†’ Sign in
   - **Google OAuth (Alternative)**: OAuth with invited email
   - **Email/Password (Legacy)**: Enter invite code + password
   - System marks invite as accepted and creates company + user + warehouse
   - User redirected to dashboard with full access

2. **Staff Invite** (for existing companies):
   - Admin creates staff invite for warehouse and role (UI pending)
   - Staff receives invite code
   - Staff signs up with invite code
   - System validates invite and creates user under existing company

**Demo Account Security**:
- Shared demo company (`is_demo = true`)
- Demo users have `is_demo = true` flag
- RLS policies: SELECT only (no INSERT/UPDATE/DELETE)
- Cannot access settings, admin panels, or real barcode generation
- Demo banner displayed on all pages
- "Request Official Access" CTA prominently shown

**Production Status (January 2025)**:
- âœ… Original invite system working (email/password + OAuth)
- âœ… Auth hook deployed and configured
- âœ… Production database: https://xejyeglxigdeznfitaxc.supabase.co
- ðŸš§ Magic link two-tier system (Phase 2B) - Implementation in progress
- ðŸš§ Resend integration pending
- ðŸš§ Demo company and data pending

### State Management

**Server Components (Default)**
- Dashboard pages fetch data on server
- No client-side state needed
- Automatic re-fetching on navigation
- Better performance and SEO

**Client Components (When Needed)**
- Forms with user interaction
- Navigation with active states
- Modals and dialogs
- Barcode scanning

**Data Fetching Pattern**:
```typescript
// Server component
export default async function ProductsPage() {
  const supabase = await createClient(); // Server client
  const { data } = await supabase.from('products').select('*');
  return <ProductsList products={data} />;
}

// Client component
'use client';
export default function ProductForm() {
  const supabase = createClient(); // Browser client
  const handleSubmit = async () => {
    await supabase.from('products').insert({...});
  };
}
```

## Development Context

### Current Status (January 2025)

**Completed**:
- âœ… Project initialization
- âœ… Database schema and migrations (18 total)
- âœ… Authentication system (email/password + Google OAuth)
- âœ… Invite system (platform and staff invites)
- âœ… Dashboard layout
- âœ… Deployment guide
- âœ… Google OAuth setup guide
- âœ… Invite system setup guide
- âœ… Production Supabase setup and migration
- âœ… Production testing (both authentication methods verified)
- âœ… Context documentation updates
- âœ… Magic link implementation plan (MAGIC_LINK_IMPLEMENTATION_PLAN.md)

**In Progress (Phase 2B - Magic Link Two-Tier System)**:
- ðŸš§ Database changes (demo flags, demo company setup)
- ðŸš§ Auth hook modification (allow signups without invite)
- ðŸš§ Callback handler update (demo vs official assignment)
- ðŸš§ Homepage with magic link demo access
- ðŸš§ Invite request form and API
- ðŸš§ Admin invite management panel
- ðŸš§ Dashboard UX for demo users
- ðŸš§ Resend email integration

**Next Steps**:
1. **Complete Phase 2B** (Magic Link System) - 25 hours estimated
   - See MAGIC_LINK_IMPLEMENTATION_PLAN.md for detailed breakdown
   - Timeline: 3-4 days full-time or 1-2 weeks part-time
2. Complete products CRUD
3. Build inventory management
4. Implement sales orders
5. Add partners management
6. Deploy to Hostinger production server

**Phase 2B Success Criteria**:
- âœ… Homepage magic link sends successfully
- âœ… Demo users assigned to demo company
- âœ… Demo users have read-only access (RLS enforced)
- âœ… Invite requests saved and reviewable
- âœ… Admin can approve/reject with invite generation
- âœ… Official signup creates new dedicated company
- âœ… Dashboard differentiates demo vs official users

### Tech Stack Versions
- Next.js: 15.1.4
- React: 19.x
- TypeScript: 5.x
- Tailwind CSS: 3.x
- Supabase: 2.75.0
- Node.js: 18+ (for deployment)

### Development Environment
- **OS**: Windows
- **Editor**: VS Code (assumed)
- **Database**: Supabase local (Docker)
- **Git**: GitHub repository
- **Package Manager**: npm

### Deployment Context

**Local Development**:
- Next.js dev server: http://localhost:3000
- Supabase Studio: http://localhost:54323
- Supabase API: http://localhost:54321

**Production**:
- Hosting: Hostinger (Node.js) - pending final deployment
- Database: Supabase Cloud (https://xejyeglxigdeznfitaxc.supabase.co)
- Authentication: Email/Password + Google OAuth (configured and tested)
- Process Manager: PM2 (documented, pending deployment)
- SSL: Let's Encrypt (via Hostinger)
- Migrations: 18 migrations successfully applied to production
- Google OAuth Redirect URI: https://xejyeglxigdeznfitaxc.supabase.co/auth/v1/callback

## Domain Knowledge

### Textile Industry Terms

**Fabric Types**:
- **Cotton**: Natural fiber, breathable
- **Polyester**: Synthetic, durable
- **Silk**: Luxury natural fiber
- **Blend**: Mix of fibers (e.g., poly-cotton)

**Measurements**:
- **GSM**: Grams per Square Meter (fabric weight/thickness)
- **Meters/Yards**: Length measurement
- **Pieces**: Individual fabric cuts
- **Kg**: Weight for some fabric types

**Quality Grades**:
- **Grade A**: First quality (export quality)
- **Grade B**: Second quality (slight defects)
- **Grade C**: Third quality (more defects)
- **Grade D**: Reject quality (major defects)

**Processing Types** (Job Works):
- **Dyeing**: Coloring fabric
- **Printing**: Patterns on fabric
- **Embroidery**: Decorative stitching
- **Washing**: Finishing process

### Business Terms

**Partners**:
- **Customer**: Buys fabric from you
- **Supplier**: Sells raw fabric to you
- **Vendor**: Provides services (dyeing, printing)
- **Agent**: Commission-based sales representative

**Stock Movement**:
- **Goods Receipt**: Incoming inventory
- **Goods Dispatch**: Outgoing inventory
- **Transfer**: Moving between own warehouses
- **Return**: Customer returning goods

**Order Types**:
- **Sales Order**: Customer order
- **Purchase Order**: Your order to supplier (not yet implemented)
- **Job Work Order**: Outsourcing order

## Project Conventions

### Naming Conventions

**Files**:
- Components: PascalCase (e.g., `ProductsList.tsx`)
- Pages: kebab-case (e.g., `sales-orders/page.tsx`)
- Utilities: camelCase (e.g., `formatDate.ts`)

**Database**:
- Tables: plural snake_case (e.g., `stock_units`)
- Columns: snake_case (e.g., `created_at`)
- Foreign keys: `{table}_id` (e.g., `company_id`)

**Code**:
- Types: PascalCase (e.g., `Product`, `StockUnit`)
- Functions: camelCase (e.g., `fetchProducts`)
- Constants: UPPER_SNAKE_CASE (e.g., `MAX_FILE_SIZE`)

### Git Commit Messages
- `feat:` - New feature
- `fix:` - Bug fix
- `docs:` - Documentation changes
- `refactor:` - Code refactoring
- `test:` - Adding tests
- `chore:` - Maintenance tasks

Example: `feat: Add products management page`

### Code Organization

**Component Structure**:
```typescript
// 1. Imports
import { createClient } from '@/lib/supabase/server';

// 2. Types
interface Props {
  // ...
}

// 3. Component
export default async function Component({ props }: Props) {
  // 4. Data fetching
  const data = await fetchData();

  // 5. Return JSX
  return <div>{/* ... */}</div>;
}
```

**API Route Structure**:
```typescript
import { createClient } from '@/lib/supabase/server';
import { NextRequest, NextResponse } from 'next/server';

export async function GET(request: NextRequest) {
  const supabase = await createClient();
  // Logic
  return NextResponse.json({ data });
}
```

## Pain Points & Solutions

### Common Issues

**Issue**: Supabase not starting
- **Solution**: Check Docker is running, restart Docker Desktop

**Issue**: Migration circular dependency
- **Solution**: Make foreign keys nullable or split migrations

**Issue**: RLS blocking queries
- **Solution**: Check user has correct `company_id` and `warehouse_id`

**Issue**: Type errors with Supabase queries
- **Solution**: Generate types: `npx supabase gen types typescript --local`

**Issue**: 401 Unauthorized errors
- **Solution**: Check JWT token is valid, user is logged in

### Best Practices

**1. Always use RLS**: Never bypass RLS policies in application code

**2. Server components by default**: Only use `'use client'` when necessary

**3. Type everything**: Use TypeScript strictly, avoid `any`

**4. Handle errors gracefully**: Show user-friendly error messages

**5. Validate inputs**: Use Zod schemas for form validation

**6. Audit changes**: Always set `created_by` and `modified_by`

**7. Test multi-tenancy**: Always test with multiple companies

**8. Test permissions**: Test both admin and staff user flows

## Key Relationships

### Entity Relationships

```
Company (1) ----< Users (N)
Company (1) ----< Warehouses (N)
Company (1) ----< Products (N)
Company (1) ----< Partners (N)
Company (1) ----< Invites (N) [staff invites only]

Warehouse (1) ----< Stock Units (N)
Warehouse (1) ----< Invites (N) [staff invites only]
Product (1) ----< Stock Units (N)

Sales Order (1) ----< Sales Order Items (N)
Sales Order Item (N) ----> Product (1)

Goods Receipt (1) ----< Stock Units (N)
Goods Dispatch (N) ----> Stock Units (1)

User (1) ----< Goods Receipts (N) [created_by]
User (1) ----< Goods Dispatches (N) [created_by]
User (1) ----< Invites (N) [invited_by]

Invite (N) ----> Company (0-1) [null for platform invites]
Invite (N) ----> Warehouse (0-1) [null for platform invites]
```

### Permission Inheritance

```
Platform (Super Admin)
â”œâ”€â”€ Can create platform invites
â”œâ”€â”€ Can view all companies (future admin panel)
â””â”€â”€ Manages platform-level settings

Company
â”œâ”€â”€ Admin User (access to ALL company warehouses)
â”‚   â”œâ”€â”€ Can create staff invites
â”‚   â”œâ”€â”€ Can manage warehouses
â”‚   â””â”€â”€ Can view all company data
â””â”€â”€ Staff User (access to ASSIGNED warehouse only)
    â”œâ”€â”€ Can only see/edit data in their warehouse
    â””â”€â”€ Cannot create invites or manage settings
```

## QR Code Generation System

### Overview
Complete QR code label generation system for stock units with PDF export capability. Allows users to select products, choose specific stock units, customize label fields, and generate printable QR codes for inventory tracking.

### Features Implemented
- âœ… Product selection with QR pending count
- âœ… Stock unit selection (grouped by batch and receipt)
- âœ… Label field customization (product + unit fields)
- âœ… PDF generation with optimized layout (12 labels per A4 page)
- âœ… Batch management with status tracking
- âœ… Download and share functionality
- âœ… Warehouse-based access control (staff see only their warehouse)

### Technical Implementation

**Database Schema**:
```sql
-- Barcode batches table
barcode_batches (
  id uuid PRIMARY KEY,
  company_id uuid NOT NULL,
  warehouse_id uuid NOT NULL,
  batch_name varchar NOT NULL,
  status varchar NOT NULL CHECK (status IN ('generated', 'printed', 'applied')),
  layout_config jsonb,
  fields_selected text[],
  pdf_url text,
  notes text,
  created_at timestamptz,
  created_by uuid
)

-- Barcode batch items junction table
barcode_batch_items (
  id uuid PRIMARY KEY,
  batch_id uuid REFERENCES barcode_batches,
  stock_unit_id uuid REFERENCES stock_units,
  barcode_generated_at timestamptz
)
```

**Label Layout** (Optimized for A4):
- **Paper Size**: A4 (210mm Ã— 297mm)
- **Label Size**: 65mm Ã— 40mm
- **Layout**: 2 labels per row Ã— 6 labels per column = 12 labels per page
- **Margins**: 10mm top/left
- **Spacing**: 3mm between labels
- **QR Code Size**: 30mm Ã— 30mm
- **Font Size**: 7pt for text fields

**Available Label Fields**:
- **Product Info**: Name, Product Number, HSN Code, Material, Color, GSM, Price
- **Unit Info**: Unit Number, Made On, Size, Wastage, Quality Grade, Location

**Status Workflow**:
- `generated` â†’ Initial status after PDF creation
- `printed` â†’ Manually marked after physical printing
- `applied` â†’ Manually marked after labels applied to stock

### User Flow

**Step 1 - Product Selection** (`/qr-codes/new`):
- View all products with QR pending counts
- Filter by material and color
- Click product to proceed to unit selection

**Step 2 - Unit Selection** (`/qr-codes/new/select-units`):
- View stock units grouped by:
  - Barcode batch (units with existing QR codes)
  - Goods receipt (units from same receipt)
- Select/deselect units with checkboxes
- See which units already have QR codes generated

**Step 3 - Configure Labels** (`/qr-codes/new/configure`):
- Auto-generated batch name (editable)
- Select which fields to include on labels
- Live preview of label layout
- Page count estimation
- Generate button creates batch and PDF

**Step 4 - View/Download** (`/qr-codes/[id]`):
- View all generated QR codes in batch
- Preview individual QR codes
- Download PDF for printing
- Share PDF via Web Share API

**Listing Page** (`/qr-codes`):
- All generated batches with key info
- Status badges (Generated/Printed/Applied)
- QR code count, warehouse, date, page count
- Direct download buttons
- View details link

### File Structure
```
app/
â”œâ”€â”€ actions/inventory/barcode.ts          # Server actions for QR operations
â”œâ”€â”€ dashboard/inventory/qr-codes/
â”‚   â”œâ”€â”€ page.tsx                          # Main listing (server component)
â”‚   â”œâ”€â”€ QRCodesClient.tsx                 # Client component with actions
â”‚   â”œâ”€â”€ [id]/page.tsx                     # Batch detail with preview
â”‚   â””â”€â”€ new/
â”‚       â”œâ”€â”€ page.tsx                      # Step 1: Product selection
â”‚       â”œâ”€â”€ select-units/page.tsx         # Step 2: Unit selection
â”‚       â””â”€â”€ configure/page.tsx            # Step 3: Label configuration
lib/
â”œâ”€â”€ types/inventory.ts                    # TypeScript types
â””â”€â”€ utils/pdf-generator.ts                # PDF generation utility
```

### PDF Generation Process
1. User submits configuration with selected units and fields
2. Server action creates batch record (status: 'generated')
3. Creates batch items linking stock units to batch
4. Fetches full stock unit data with product details
5. Maps selected fields to label data
6. Generates QR codes as data URLs using `qrcode` library
7. Uses `jspdf` to create PDF with optimized layout
8. Uploads PDF to Supabase Storage (`documents` bucket)
9. Updates batch with PDF public URL
10. Revalidates cache paths for UI updates

### Key Functions

**`createBarcodeBatch(input)`** - Main server action:
- Validates user authentication and permissions
- Fetches warehouse_id from stock units
- Creates barcode batch and items
- Generates PDF with QR codes
- Uploads to storage
- Returns success + batch ID

**`generateQRCodesPDF(labels, batchName, layout)`** - PDF generator:
- Uses jsPDF for PDF creation
- Generates QR codes with high error correction (level H)
- Positions labels in optimized grid layout
- Supports dynamic field count and wrapping
- Returns ArrayBuffer for upload

**`getStockUnitsForQRGeneration(productId)`** - Data fetching:
- Fetches stock units with product details
- Enriches with batch info (existing QR codes)
- Enriches with receipt info (supplier, receipt number)
- Applies RLS filtering (company + warehouse for staff)

### Important Notes

**Column Names**:
- Products table uses `selling_price_per_unit` (not `sale_price`)
- Stock units use `manufacturing_date` (not `manufacture_date`)
- Stock units use `wastage` (not `wastage_quantity`)
- Stock units use `location_description` (not `location`)

**Status Constraints**:
- Only three valid status values: `generated`, `printed`, `applied`
- No `generating`, `failed`, or `completed` status (database constraint)

**Cache Revalidation**:
- After batch creation, revalidate:
  - `/dashboard/inventory/qr-codes` (listing page)
  - `/dashboard/inventory/qr-codes/new` (product selection)
  - `/dashboard/inventory/qr-codes/${batchId}` (detail page)
- Use `router.refresh()` on client after successful creation

**No Deleted_At Column**:
- The `barcode_batches` table does NOT have a `deleted_at` column
- Do not filter by `deleted_at` when querying batches

### Libraries Used
- `jspdf` (v2.5.2): PDF generation
- `qrcode` (v1.5.4): QR code generation (server-side)
- `qrcode.react` (v4.1.0): QR code display (client-side)

## Future Considerations

### Scalability
- Consider API rate limiting
- Implement caching for frequently accessed data
- Optimize database queries with indexes
- Consider CDN for static assets

### Features to Add
- Real-time notifications (Supabase Realtime)
- Advanced reporting (charts, graphs)
- Export functionality (PDF, Excel)
- Email notifications for orders
- SMS updates for customers
- Multi-language support (Hindi, Gujarati, etc.)

### Technical Debt
- Add comprehensive error handling
- Implement logging system
- Add monitoring and alerting
- Create backup strategy
- Document API endpoints

---

**Last Updated**: January 2025
**Project Status**: Active Development - Phase 5 (Products Management)
